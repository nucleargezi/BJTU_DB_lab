// 使用内置表格功能，不依赖外部包

#set page(
  paper: "a4",
  margin: (x: 2.5cm, y: 2cm),
  numbering: "1",
)

#set text(font: (
  (name: "Latin Modern Roman", covers: "latin-in-cjk"), // 西文字体
  "Noto Serif CJK SC" // 中文字体 - 思源宋体
), size: 10.5pt, lang: "zh")


#set heading(
  numbering: "1.1",
)

#set par(
  justify: true,
  leading: 0.65em,
  first-line-indent: 2em,
)

#show heading: it => {
  set par(first-line-indent: 0em)
  it
  v(0.5em)
}

#align(center)[
  #text(size: 18pt, weight: "bold")[
    设计报告和系统架构设计文档要求
  ]
]

#v(1em)

#align(center)[
  #text(size: 14pt)[
    22281089 陈可致
  ]
]

#v(2em)

= 课程设计内容：基于Rucbase的数据库存储管理功能实现

== 基本要求

=== 实验环境搭建

本实验基于Rucbase数据库系统框架进行开发。Rucbase是一个教学用的关系型数据库管理系统，其GitHub仓库地址为：https://github.com/ruc-deke/rucbase-lab。实验环境配置包括：

- 操作系统：Linux (Ubuntu 24.04.2 LTS)
- 编译器：GCC 13.3.0
- 构建工具：CMake 3.28.3

=== 实验目标

本次实验的主要目标是实现数据库存储管理系统的核心组件，具体包括：

1. *任务1.1*：实现磁盘存储管理器（DiskManager）
2. *任务1.2*：实现缓冲池替换策略（LRU Replacer）
3. *任务1.3*：实现缓冲池管理器（BufferPoolManager）
4. *任务2.1*：实现记录操作功能
5. *任务2.2*：实现记录迭代器

== 实验设计思路

=== 系统架构设计

数据库存储管理系统采用分层架构设计，从底层到上层依次为：

1. *磁盘存储层*：负责与操作系统文件系统交互，提供页面级别的读写操作
2. *缓冲池管理层*：在内存中维护页面缓存，减少磁盘I/O开销
3. *记录管理层*：提供记录级别的CRUD操作接口

=== 核心组件设计

==== 磁盘存储管理器（DiskManager）

磁盘存储管理器是存储系统的最底层组件，主要功能包括：

- *页面读写*：通过文件描述符和页面编号定位磁盘页面，调用系统调用`read()`和`write()`进行数据传输
- *页面分配*：采用简单的自增策略分配页面编号
- *文件操作*：提供文件的创建、打开、关闭、删除等基本操作

关键实现要点：
- 使用`lseek()`函数计算页面在文件中的偏移量
- 通过`struct stat`检查文件是否存在
- 维护文件描述符与文件路径的映射关系
- 实现完善的错误处理机制，针对不同错误类型抛出相应异常

==== 缓冲池替换策略（LRU Replacer）

采用最近最少使用（LRU）算法实现页面替换策略：

- *数据结构*：使用双向链表维护页面访问顺序，使用哈希表实现O(1)时间复杂度的查找
- *Pin操作*：将页面从LRU链表中移除，表示该页面正在被使用
- *Unpin操作*：将页面插入到LRU链表头部，表示该页面可以被替换
- *Victim操作*：选择LRU链表尾部的页面进行淘汰

线程安全保证：
- 使用`std::mutex`对所有操作进行加锁，确保并发安全

==== 缓冲池管理器（BufferPoolManager）

缓冲池管理器协调磁盘存储管理器和替换策略，提供页面级别的缓存服务：

- *页面获取*：首先在缓冲池中查找，如果不存在则从磁盘读取
- *页面创建*：分配新的页面编号，在缓冲池中创建对应页面
- *页面淘汰*：当缓冲池满时，使用LRU策略选择淘汰页面
- *脏页处理*：淘汰脏页前必须先写回磁盘

关键数据结构：
- `page_table_`：页面ID到帧ID的映射
- `free_list_`：空闲帧列表
- `pages_`：页面数组
- `replacer_`：LRU替换器

==== 记录管理器（RMFileHandle & RMScan）

记录管理器在页面管理的基础上提供记录级别的操作：

- *记录存储*：采用定长记录组织形式，使用位图（bitmap）跟踪槽位使用情况
- *记录操作*：提供插入、删除、更新、查询等基本操作
- *记录遍历*：实现迭代器模式，支持顺序遍历文件中的所有记录

= 实验结果

== 测试结果

根据实验要求，本次实验包含四个主要测试模块，测试结果如下：

#table(
  columns: 4,
  align: center,
  fill: (x, y) => if y == 0 { gray.lighten(40%) },
  [*任务点*], [*测试文件*], [*分值*], [*测试结果*],
  [任务1.1 磁盘存储管理器], [src/test/storage/disk_manager_test.cpp], [10], [✓ 通过],
  [任务1.2 缓冲池替换策略], [src/test/storage/lru_replacer_test.cpp], [20], [✓ 通过],
  [任务1.3 缓冲池管理器], [src/test/storage/buffer_pool_manager_test.cpp], [40], [✓ 通过],
  [任务2 记录管理器], [src/test/storage/record_manager_test.cpp], [30], [✓ 通过],
)

== 关键问题解决

=== 错误处理机制优化

在实现过程中，发现原始的错误处理机制不够精确。具体问题是在文件操作失败时，系统统一抛出`UnixError`异常，但测试用例期望针对特定错误（如文件不存在）抛出更具体的异常类型。

*解决方案*：
- 在`open_file()`方法中，当`errno == ENOENT`时抛出`FileNotFoundError`而非`UnixError`
- 在`destroy_file()`方法中，同样针对文件不存在的情况抛出`FileNotFoundError`

修改后的代码片段：
```cpp
if (open(path.c_str(), O_RDWR) == -1) {
    if (errno == ENOENT) {
        throw FileNotFoundError(path);
    }
    throw UnixError();
}
```

=== 并发控制设计

为保证多线程环境下的数据一致性，在关键组件中实现了适当的并发控制：

- *LRU Replacer*：使用互斥锁保护内部数据结构
- *Buffer Pool Manager*：对每个公共方法进行加锁，确保原子性操作

== 性能分析

=== 时间复杂度分析

- *LRU操作*：Pin、Unpin、Victim操作均为O(1)时间复杂度
- *页面查找*：通过哈希表实现O(1)平均时间复杂度
- *记录操作*：插入、删除、更新操作的时间复杂度为O(1)

=== 空间复杂度分析

- *缓冲池*：固定大小的页面数组，空间复杂度为O(pool_size)
- *页面表*：存储页面ID到帧ID的映射，空间复杂度为O(pool_size)
- *LRU链表*：最多存储pool_size个节点，空间复杂度为O(pool_size)

= 计分

根据实验要求，本次实验总分为100分，各任务点得分情况如下：

#table(
  columns: 3,
  align: center,
  fill: (x, y) => if y == 0 { gray.lighten(40%) } else if y == 5 { gray.lighten(20%) },
  [*任务点*], [*分值*], [*获得分数*],
  [任务1.1 磁盘存储管理器], [10], [10],
  [任务1.2 缓冲池替换策略], [20], [20],
  [任务1.3 缓冲池管理器], [40], [40],
  [任务2 记录管理器], [30], [30],
  table.cell(colspan: 2)[*总分*], [*100*],
)

= 总结与展望

== 实验总结

本次实验成功实现了数据库存储管理系统的核心功能，包括磁盘存储管理、缓冲池管理和记录管理。通过本次实验，深入理解了：

1. 数据库存储系统的分层架构设计
2. 缓冲池管理的核心算法和实现技巧
3. 页面级别和记录级别的数据组织方式
4. 并发控制在存储系统中的重要性

== 改进方向

1. *性能优化*：可以考虑实现更高效的替换算法，如Clock算法或LRU-K算法
2. *并发控制*：可以实现更细粒度的锁机制，提高并发性能
3. *错误恢复*：可以添加更完善的错误恢复机制，提高系统的健壮性
4. *监控统计*：可以添加性能监控和统计功能，便于系统调优

通过本次实验，不仅掌握了数据库存储管理的核心技术，也为后续的索引管理、查询执行和并发控制实验奠定了坚实的基础。